"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareFunctions = exports.checkAvailability = exports.existingBackend = exports.scheduleIdForFunction = exports.topicName = exports.scheduleName = exports.sameFunctionName = exports.functionName = exports.isEmptyBackend = exports.empty = exports.isScheduleTriggered = exports.isEventTriggered = exports.isHttpsTriggered = exports.SCHEDULED_FUNCTION_LABEL = exports.memoryOptionDisplayName = exports.triggerTag = exports.isEventTrigger = void 0;
const gcf = require("../../gcp/cloudfunctions");
const gcfV2 = require("../../gcp/cloudfunctionsv2");
const utils = require("../../utils");
const error_1 = require("../../error");
const previews_1 = require("../../previews");
function isEventTrigger(trigger) {
    return "eventType" in trigger;
}
exports.isEventTrigger = isEventTrigger;
function triggerTag(fn) {
    var _a, _b;
    if ((_a = fn.labels) === null || _a === void 0 ? void 0 : _a["deployment-scheduled"]) {
        if (fn.platform === "gcfv1") {
            return "v1.scheduled";
        }
        return "v2.scheduled";
    }
    if ((_b = fn.labels) === null || _b === void 0 ? void 0 : _b["deployment-callable"]) {
        if (fn.platform === "gcfv1") {
            return "v1.callable";
        }
        return "v2.callable";
    }
    if (!isEventTrigger(fn.trigger)) {
        if (fn.platform === "gcfv1") {
            return "v1.https";
        }
        return "v2.https";
    }
    return fn.trigger.eventType;
}
exports.triggerTag = triggerTag;
function memoryOptionDisplayName(option) {
    return {
        128: "128MB",
        256: "256MB",
        512: "512MB",
        1024: "1GB",
        2048: "2GB",
        4096: "4GB",
        8192: "8GB",
    }[option];
}
exports.memoryOptionDisplayName = memoryOptionDisplayName;
exports.SCHEDULED_FUNCTION_LABEL = Object.freeze({ deployment: "firebase-schedule" });
function isHttpsTriggered(triggered) {
    return {}.hasOwnProperty.call(triggered, "httpsTrigger");
}
exports.isHttpsTriggered = isHttpsTriggered;
function isEventTriggered(triggered) {
    return {}.hasOwnProperty.call(triggered, "eventTrigger");
}
exports.isEventTriggered = isEventTriggered;
function isScheduleTriggered(triggered) {
    return {}.hasOwnProperty.call(triggered, "scheduleTrigger");
}
exports.isScheduleTriggered = isScheduleTriggered;
function empty() {
    return {
        requiredAPIs: {},
        endpoints: [],
        cloudFunctions: [],
        schedules: [],
        topics: [],
        environmentVariables: {},
    };
}
exports.empty = empty;
function isEmptyBackend(backend) {
    return (Object.keys(backend.requiredAPIs).length == 0 &&
        backend.cloudFunctions.length === 0 &&
        backend.schedules.length === 0 &&
        backend.topics.length === 0);
}
exports.isEmptyBackend = isEmptyBackend;
function functionName(cloudFunction) {
    return `projects/${cloudFunction.project}/locations/${cloudFunction.region}/functions/${cloudFunction.id}`;
}
exports.functionName = functionName;
exports.sameFunctionName = (func) => (test) => {
    return func.id === test.id && func.region === test.region && func.project == test.project;
};
function scheduleName(schedule, appEngineLocation) {
    return `projects/${schedule.project}/locations/${appEngineLocation}/jobs/${schedule.id}`;
}
exports.scheduleName = scheduleName;
function topicName(topic) {
    return `projects/${topic.project}/topics/${topic.id}`;
}
exports.topicName = topicName;
function scheduleIdForFunction(cloudFunction) {
    return `firebase-schedule-${cloudFunction.id}-${cloudFunction.region}`;
}
exports.scheduleIdForFunction = scheduleIdForFunction;
async function existingBackend(context, forceRefresh) {
    const ctx = context;
    if (!ctx.loadedExistingBackend || forceRefresh) {
        await loadExistingBackend(ctx);
    }
    return ctx.existingBackend;
}
exports.existingBackend = existingBackend;
async function loadExistingBackend(ctx) {
    var _a, _b, _c;
    ctx.loadedExistingBackend = true;
    ctx.existingBackend = Object.assign({}, empty());
    ctx.unreachableRegions = {
        gcfV1: [],
        gcfV2: [],
    };
    const gcfV1Results = await gcf.listAllFunctions(ctx.projectId);
    for (const apiFunction of gcfV1Results.functions) {
        const specFunction = gcf.specFromFunction(apiFunction);
        ctx.existingBackend.cloudFunctions.push(specFunction);
        const isScheduled = ((_a = apiFunction.labels) === null || _a === void 0 ? void 0 : _a["deployment-scheduled"]) === "true";
        if (isScheduled) {
            const id = scheduleIdForFunction(specFunction);
            ctx.existingBackend.schedules.push({
                id,
                project: specFunction.project,
                transport: "pubsub",
                targetService: {
                    id: specFunction.id,
                    region: specFunction.region,
                    project: specFunction.project,
                },
            });
            ctx.existingBackend.topics.push({
                id,
                project: specFunction.project,
                labels: exports.SCHEDULED_FUNCTION_LABEL,
                targetService: {
                    id: specFunction.id,
                    region: specFunction.region,
                    project: specFunction.project,
                },
            });
        }
    }
    ctx.unreachableRegions.gcfV1 = gcfV1Results.unreachable;
    if (!previews_1.previews.functionsv2) {
        return;
    }
    const gcfV2Results = await gcfV2.listAllFunctions(ctx.projectId);
    for (const apiFunction of gcfV2Results.functions) {
        const specFunction = gcfV2.specFromFunction(apiFunction);
        ctx.existingBackend.cloudFunctions.push(specFunction);
        const pubsubScheduled = ((_b = apiFunction.labels) === null || _b === void 0 ? void 0 : _b["deployment-scheduled"]) === "true";
        const httpsScheduled = ((_c = apiFunction.labels) === null || _c === void 0 ? void 0 : _c["deployment-scheduled"]) === "https";
        if (pubsubScheduled) {
            const id = scheduleIdForFunction(specFunction);
            ctx.existingBackend.schedules.push({
                id,
                project: specFunction.project,
                transport: "pubsub",
                targetService: {
                    id: specFunction.id,
                    region: specFunction.region,
                    project: specFunction.project,
                },
            });
            ctx.existingBackend.topics.push({
                id,
                project: specFunction.project,
                labels: exports.SCHEDULED_FUNCTION_LABEL,
                targetService: {
                    id: specFunction.id,
                    region: specFunction.region,
                    project: specFunction.project,
                },
            });
        }
        if (httpsScheduled) {
            const id = scheduleIdForFunction(specFunction);
            ctx.existingBackend.schedules.push({
                id,
                project: specFunction.project,
                transport: "https",
                targetService: {
                    id: specFunction.id,
                    region: specFunction.region,
                    project: specFunction.project,
                },
            });
        }
    }
    ctx.unreachableRegions.gcfV2 = gcfV2Results.unreachable;
}
async function checkAvailability(context, want) {
    const ctx = context;
    if (!ctx.loadedExistingBackend) {
        await loadExistingBackend(ctx);
    }
    const gcfV1Regions = new Set();
    const gcfV2Regions = new Set();
    for (const fn of want.cloudFunctions) {
        if (fn.platform == "gcfv1") {
            gcfV1Regions.add(fn.region);
        }
        else {
            gcfV2Regions.add(fn.region);
        }
    }
    const neededUnreachableV1 = ctx.unreachableRegions.gcfV1.filter((region) => gcfV1Regions.has(region));
    const neededUnreachableV2 = ctx.unreachableRegions.gcfV2.filter((region) => gcfV2Regions.has(region));
    if (neededUnreachableV1.length) {
        throw new error_1.FirebaseError("The following Cloud Functions regions are currently unreachable:\n\t" +
            neededUnreachableV1.join("\n\t") +
            "\nThis deployment contains functions in those regions. Please try again in a few minutes, or exclude these regions from your deployment.");
    }
    if (neededUnreachableV2.length) {
        throw new error_1.FirebaseError("The following Cloud Functions V2 regions are currently unreachable:\n\t" +
            neededUnreachableV2.join("\n\t") +
            "\nThis deployment contains functions in those regions. Please try again in a few minutes, or exclude these regions from your deployment.");
    }
    if (ctx.unreachableRegions.gcfV1.length) {
        utils.logLabeledWarning("functions", "The following Cloud Functions regions are currently unreachable:\n" +
            ctx.unreachableRegions.gcfV1.join("\n") +
            "\nCloud Functions in these regions won't be deleted.");
    }
    if (ctx.unreachableRegions.gcfV2.length) {
        utils.logLabeledWarning("functions", "The following Cloud Functions V2 regions are currently unreachable:\n" +
            ctx.unreachableRegions.gcfV2.join("\n") +
            "\nCloud Functions in these regions won't be deleted.");
    }
}
exports.checkAvailability = checkAvailability;
function compareFunctions(left, right) {
    if (left.platform != right.platform) {
        return right.platform < left.platform ? -1 : 1;
    }
    if (left.region < right.region) {
        return -1;
    }
    if (left.region > right.region) {
        return 1;
    }
    if (left.id < right.id) {
        return -1;
    }
    if (left.id > right.id) {
        return 1;
    }
    return 0;
}
exports.compareFunctions = compareFunctions;
