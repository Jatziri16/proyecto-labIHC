"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schedulerDeploymentHandler = exports.deleteTopicTask = exports.deleteScheduleTask = exports.upsertScheduleTask = exports.runRegionalFunctionDeployment = exports.functionsDeploymentHandler = exports.deleteFunctionTask = exports.updateFunctionTask = exports.createFunctionTask = void 0;
const clc = require("cli-color");
const logger_1 = require("../../logger");
const operation_poller_1 = require("../../operation-poller");
const api_1 = require("../../api");
const runtimes_1 = require("./runtimes");
const backend = require("./backend");
const cloudscheduler = require("../../gcp/cloudscheduler");
const deploymentTool = require("../../deploymentTool");
const gcf = require("../../gcp/cloudfunctions");
const gcfV2 = require("../../gcp/cloudfunctionsv2");
const cloudrun = require("../../gcp/run");
const helper = require("./functionsDeployHelper");
const pubsub = require("../../gcp/pubsub");
const utils = require("../../utils");
const error_1 = require("../../error");
const track_1 = require("../../track");
const gcfV1PollerOptions = {
    apiOrigin: api_1.functionsOrigin,
    apiVersion: gcf.API_VERSION,
    masterTimeout: 25 * 60 * 1000,
};
const gcfV2PollerOptions = {
    apiOrigin: api_1.functionsV2Origin,
    apiVersion: gcfV2.API_VERSION,
    masterTimeout: 25 * 60 * 1000,
};
const pollerOptionsByPlatform = {
    gcfv1: gcfV1PollerOptions,
    gcfv2: gcfV2PollerOptions,
};
function createFunctionTask(params, fn, sourceToken, onPoll) {
    const fnName = backend.functionName(fn);
    const run = async () => {
        var _a;
        utils.logBullet(clc.bold.cyan("functions: ") +
            "creating " +
            runtimes_1.getHumanFriendlyRuntimeName(fn.runtime) +
            " function " +
            clc.bold(helper.getFunctionLabel(fn)) +
            "...");
        let op;
        if (fn.platform === "gcfv1") {
            const apiFunction = gcf.functionFromSpec(fn, params.sourceUrl);
            if (sourceToken) {
                apiFunction.sourceToken = sourceToken;
            }
            op = await gcf.createFunction(apiFunction);
        }
        else {
            const apiFunction = gcfV2.functionFromSpec(fn, params.storage[fn.region]);
            if ((_a = apiFunction.eventTrigger) === null || _a === void 0 ? void 0 : _a.pubsubTopic) {
                try {
                    await pubsub.getTopic(apiFunction.eventTrigger.pubsubTopic);
                }
                catch (err) {
                    if (err.status !== 404) {
                        throw new error_1.FirebaseError("Unexpected error looking for Pub/Sub topic", {
                            original: err,
                        });
                    }
                    await pubsub.createTopic({
                        name: apiFunction.eventTrigger.pubsubTopic,
                    });
                }
            }
            op = await gcfV2.createFunction(apiFunction);
        }
        const cloudFunction = await operation_poller_1.pollOperation(Object.assign(Object.assign({}, pollerOptionsByPlatform[fn.platform]), { pollerName: `create-${fnName}`, operationResourceName: op.name, onPoll }));
        if (!backend.isEventTrigger(fn.trigger)) {
            const invoker = fn.trigger.invoker || ["public"];
            if (invoker[0] !== "private") {
                try {
                    if (fn.platform === "gcfv1") {
                        await gcf.setInvokerCreate(params.projectId, fnName, invoker);
                    }
                    else {
                        const serviceName = cloudFunction.serviceConfig.service;
                        cloudrun.setInvokerCreate(params.projectId, serviceName, invoker);
                    }
                }
                catch (err) {
                    params.errorHandler.record("error", fnName, "set invoker", err.message);
                }
            }
        }
        if (fn.platform !== "gcfv1") {
            await setConcurrency(cloudFunction.serviceConfig.service, fn.concurrency || 80);
        }
    };
    return {
        run,
        data: fn,
        operationType: "create",
    };
}
exports.createFunctionTask = createFunctionTask;
function updateFunctionTask(params, fn, sourceToken, onPoll) {
    const fnName = backend.functionName(fn);
    const run = async () => {
        var _a;
        utils.logBullet(clc.bold.cyan("functions: ") +
            "updating " +
            runtimes_1.getHumanFriendlyRuntimeName(fn.runtime) +
            " function " +
            clc.bold(helper.getFunctionLabel(fn)) +
            "...");
        let opName;
        if (fn.platform == "gcfv1") {
            const apiFunction = gcf.functionFromSpec(fn, params.sourceUrl);
            if (sourceToken) {
                apiFunction.sourceToken = sourceToken;
            }
            opName = (await gcf.updateFunction(apiFunction)).name;
        }
        else {
            const apiFunction = gcfV2.functionFromSpec(fn, params.storage[fn.region]);
            if ((_a = apiFunction.eventTrigger) === null || _a === void 0 ? void 0 : _a.pubsubTopic) {
                delete apiFunction.eventTrigger.pubsubTopic;
            }
            opName = (await gcfV2.updateFunction(apiFunction)).name;
        }
        const pollerOptions = Object.assign(Object.assign({}, pollerOptionsByPlatform[fn.platform]), { pollerName: `update-${fnName}`, operationResourceName: opName, onPoll });
        const cloudFunction = await operation_poller_1.pollOperation(pollerOptions);
        if (!backend.isEventTrigger(fn.trigger) && fn.trigger.invoker) {
            try {
                if (fn.platform === "gcfv1") {
                    await gcf.setInvokerUpdate(params.projectId, fnName, fn.trigger.invoker);
                }
                else {
                    const serviceName = cloudFunction.serviceConfig.service;
                    cloudrun.setInvokerUpdate(params.projectId, serviceName, fn.trigger.invoker);
                }
            }
            catch (err) {
                params.errorHandler.record("error", fnName, "set invoker", err.message);
            }
        }
        if ("concurrency" in fn) {
            if (fn.platform === "gcfv1") {
                throw new error_1.FirebaseError("Precondition failed: GCFv1 does not support concurrency");
            }
            else {
                await setConcurrency(cloudFunction.serviceConfig.service, fn.concurrency || 80);
            }
        }
    };
    return {
        run,
        data: fn,
        operationType: "update",
    };
}
exports.updateFunctionTask = updateFunctionTask;
function deleteFunctionTask(params, fn) {
    const fnName = backend.functionName(fn);
    const run = async () => {
        utils.logBullet(clc.bold.cyan("functions: ") +
            "deleting function " +
            clc.bold(helper.getFunctionLabel(fnName)) +
            "...");
        let res;
        if (fn.platform == "gcfv1") {
            res = await gcf.deleteFunction(fnName);
        }
        else {
            res = await gcfV2.deleteFunction(fnName);
        }
        const pollerOptions = Object.assign(Object.assign({}, pollerOptionsByPlatform[fn.platform]), { pollerName: `delete-${fnName}`, operationResourceName: res.name });
        await operation_poller_1.pollOperation(pollerOptions);
    };
    return {
        run,
        data: fn,
        operationType: "delete",
    };
}
exports.deleteFunctionTask = deleteFunctionTask;
async function setConcurrency(name, concurrency) {
    const err = null;
    while (true) {
        const service = await cloudrun.getService(name);
        delete service.status;
        delete service.spec.template.metadata.name;
        service.spec.template.spec.containerConcurrency = concurrency;
        try {
            await cloudrun.replaceService(name, service);
            return;
        }
        catch (err) {
            if (err.status !== 409) {
                throw new error_1.FirebaseError("Unexpected error while trying to set concurrency", {
                    original: err,
                });
            }
        }
    }
}
function functionsDeploymentHandler(timer, errorHandler) {
    return async (task) => {
        var _a, _b, _c, _d;
        let result;
        const fnName = backend.functionName(task.data);
        try {
            timer.startTimer(fnName, task.operationType);
            result = await task.run();
            helper.printSuccess(task.data, task.operationType);
            const duration = timer.endTimer(fnName);
            track_1.track("function_deploy_success", backend.triggerTag(task.data), duration);
        }
        catch (err) {
            if (((_c = (_b = (_a = err.original) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.response) === null || _c === void 0 ? void 0 : _c.statusCode) === 429) {
                throw err;
            }
            errorHandler.record("error", fnName, task.operationType, ((_d = err.original) === null || _d === void 0 ? void 0 : _d.message) || "");
            const duration = timer.endTimer(fnName);
            track_1.track("function_deploy_failure", backend.triggerTag(task.data), duration);
        }
        return result;
    };
}
exports.functionsDeploymentHandler = functionsDeploymentHandler;
async function runRegionalFunctionDeployment(params, region, regionalDeployment, queue) {
    let resolveToken;
    const getRealToken = new Promise((resolve) => (resolveToken = resolve));
    let firstToken = true;
    const getToken = () => {
        if (firstToken) {
            firstToken = false;
            return Promise.resolve(undefined);
        }
        return getRealToken;
    };
    const onPollFn = (op) => {
        var _a, _b;
        if (((_a = op.metadata) === null || _a === void 0 ? void 0 : _a.sourceToken) || op.done) {
            logger_1.logger.debug(`Got sourceToken ${op.metadata.sourceToken} for region ${region}`);
            resolveToken((_b = op.metadata) === null || _b === void 0 ? void 0 : _b.sourceToken);
        }
    };
    const deploy = async (functionSpec, createTask) => {
        functionSpec.labels = Object.assign(Object.assign({}, (functionSpec.labels || {})), deploymentTool.labels());
        let task;
        if (functionSpec.platform == "gcfv2") {
            task = createTask(params, functionSpec, undefined, () => undefined);
        }
        else {
            const sourceToken = await getToken();
            task = createTask(params, functionSpec, sourceToken, onPollFn);
        }
        return queue.run(task);
    };
    const deploys = [];
    deploys.push(...regionalDeployment.functionsToCreate.map((fn) => deploy(fn, createFunctionTask)));
    deploys.push(...regionalDeployment.functionsToUpdate.map(async (update) => {
        if (update.deleteAndRecreate) {
            await queue.run(deleteFunctionTask(params, update.func));
            return deploy(update.func, createFunctionTask);
        }
        else {
            return deploy(update.func, updateFunctionTask);
        }
    }));
    await Promise.all(deploys);
    const deletes = regionalDeployment.functionsToDelete.map(async (fn) => {
        const task = deleteFunctionTask(params, fn);
        await queue.run(task);
    });
    await Promise.all(deletes);
}
exports.runRegionalFunctionDeployment = runRegionalFunctionDeployment;
function upsertScheduleTask(params, schedule, appEngineLocation) {
    const run = async () => {
        const job = cloudscheduler.jobFromSpec(schedule, appEngineLocation);
        await cloudscheduler.createOrReplaceJob(job);
    };
    return {
        run,
        data: schedule,
        operationType: "upsert schedule",
    };
}
exports.upsertScheduleTask = upsertScheduleTask;
function deleteScheduleTask(params, schedule, appEngineLocation) {
    const run = async () => {
        const jobName = backend.scheduleName(schedule, appEngineLocation);
        await cloudscheduler.deleteJob(jobName);
    };
    return {
        run,
        data: schedule,
        operationType: "delete schedule",
    };
}
exports.deleteScheduleTask = deleteScheduleTask;
function deleteTopicTask(params, topic) {
    const run = async () => {
        const topicName = backend.topicName(topic);
        await pubsub.deleteTopic(topicName);
    };
    return {
        run,
        data: topic,
        operationType: "delete topic",
    };
}
exports.deleteTopicTask = deleteTopicTask;
exports.schedulerDeploymentHandler = (errorHandler) => async (task) => {
    try {
        const result = await task.run();
        helper.printSuccess(task.data.targetService, task.operationType);
        return result;
    }
    catch (err) {
        if (err.status === 429) {
            throw err;
        }
        else if (err.status !== 404) {
            errorHandler.record("error", backend.functionName(task.data.targetService), task.operationType, err.message || "");
        }
    }
};
