"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.backendFromV1Alpha1 = void 0;
const backend = require("../../backend");
const parsing_1 = require("./parsing");
function backendFromV1Alpha1(yaml, project, region, runtime) {
    const bkend = JSON.parse(JSON.stringify(yaml));
    delete bkend.specVersion;
    tryValidate(bkend);
    fillDefaults(bkend, project, region, runtime);
    return bkend;
}
exports.backendFromV1Alpha1 = backendFromV1Alpha1;
function tryValidate(typed) {
    var _a, _b;
    parsing_1.assertKeyTypes("", typed, {
        requiredAPIs: "object",
        endpoints: "array",
        cloudFunctions: "array",
        topics: "array",
        schedules: "array",
        environmentVariables: "object",
    });
    parsing_1.requireKeys("", typed, "cloudFunctions");
    for (let ndx = 0; ndx < typed.cloudFunctions.length; ndx++) {
        const prefix = `cloudFunctions[${ndx}]`;
        const func = typed.cloudFunctions[ndx];
        parsing_1.requireKeys(prefix, func, "platform", "id", "entryPoint", "trigger");
        parsing_1.assertKeyTypes(prefix, func, {
            platform: "string",
            id: "string",
            region: "string",
            project: "string",
            runtime: "string",
            entryPoint: "string",
            availableMemoryMb: "number",
            maxInstances: "number",
            minInstances: "number",
            concurrency: "number",
            serviceAccountEmail: "string",
            timeout: "string",
            trigger: "object",
            vpcConnector: "string",
            vpcConnectorEgressSettings: "string",
            labels: "object",
            ingressSettings: "string",
            environmentVariables: "omit",
            uri: "omit",
            sourceUploadUrl: "omit",
        });
        if (backend.isEventTrigger(func.trigger)) {
            parsing_1.requireKeys(prefix + ".trigger", func.trigger, "eventType", "eventFilters");
            parsing_1.assertKeyTypes(prefix + ".trigger", func.trigger, {
                eventFilters: "object",
                eventType: "string",
                retry: "boolean",
                region: "string",
                serviceAccountEmail: "string",
            });
        }
        else {
            parsing_1.assertKeyTypes(prefix + ".trigger", func.trigger, {
                invoker: "array",
            });
        }
    }
    for (let ndx = 0; ndx < ((_a = typed.topics) === null || _a === void 0 ? void 0 : _a.length); ndx++) {
        let prefix = `topics[${ndx}]`;
        const topic = typed.topics[ndx];
        parsing_1.requireKeys(prefix, topic, "id", "targetService");
        parsing_1.assertKeyTypes(prefix, topic, {
            id: "string",
            labels: "object",
            project: "string",
            targetService: "object",
        });
        prefix += ".targetService";
        parsing_1.requireKeys(prefix, topic.targetService, "id");
        parsing_1.assertKeyTypes(prefix, topic.targetService, {
            id: "string",
            project: "string",
            region: "string",
        });
    }
    for (let ndx = 0; ndx < ((_b = typed.schedules) === null || _b === void 0 ? void 0 : _b.length); ndx++) {
        let prefix = `schedules[${ndx}]`;
        const schedule = typed.schedules[ndx];
        parsing_1.requireKeys(prefix, schedule, "id", "schedule", "transport", "targetService");
        parsing_1.assertKeyTypes(prefix, schedule, {
            id: "string",
            project: "string",
            retryConfig: "object",
            schedule: "string",
            timeZone: "string",
            transport: "string",
            targetService: "object",
        });
        parsing_1.assertKeyTypes(prefix + ".retryConfig", schedule.retryConfig, {
            maxBackoffDuration: "string",
            minBackoffDuration: "string",
            maxDoublings: "number",
            maxRetryDuration: "string",
            retryCount: "number",
        });
        parsing_1.requireKeys((prefix = ".targetService"), schedule.targetService, "id");
        parsing_1.assertKeyTypes(prefix + ".targetService", schedule.targetService, {
            id: "string",
            project: "string",
            region: "string",
        });
    }
}
function fillDefaults(want, project, region, runtime) {
    want.requiredAPIs = want.requiredAPIs || {};
    want.environmentVariables = want.environmentVariables || {};
    want.schedules = want.schedules || [];
    want.topics = want.topics || [];
    want.endpoints = want.endpoints || [];
    for (const cloudFunction of want.cloudFunctions) {
        if (!cloudFunction.project) {
            cloudFunction.project = project;
        }
        if (!cloudFunction.region) {
            cloudFunction.region = region;
        }
        if (!cloudFunction.runtime) {
            cloudFunction.runtime = runtime;
        }
    }
    for (const topic of want.topics) {
        if (!topic.project) {
            topic.project = project;
        }
        if (!topic.targetService.project) {
            topic.targetService.project = project;
        }
        if (!topic.targetService.region) {
            topic.targetService.region = region;
        }
    }
    for (const schedule of want.schedules) {
        if (!schedule.project) {
            schedule.project = project;
        }
        if (!schedule.targetService.project) {
            schedule.targetService.project = project;
        }
        if (!schedule.targetService.region) {
            schedule.targetService.region = region;
        }
    }
}
