"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDeploymentPlan = exports.calculateRegionalFunctionChanges = exports.allRegions = exports.functionsByRegion = void 0;
const functionsDeployHelper_1 = require("./functionsDeployHelper");
const validate_1 = require("./validate");
const deploymentTool_1 = require("../../deploymentTool");
const utils_1 = require("../../utils");
const backend = require("./backend");
const gcfv2 = require("../../gcp/cloudfunctionsv2");
function functionsByRegion(allFunctions) {
    const partitioned = {};
    for (const fn of allFunctions) {
        partitioned[fn.region] = partitioned[fn.region] || [];
        partitioned[fn.region].push(fn);
    }
    return partitioned;
}
exports.functionsByRegion = functionsByRegion;
function allRegions(spec, existing) {
    return Object.keys(Object.assign(Object.assign({}, spec), existing));
}
exports.allRegions = allRegions;
const matchesId = (hasId) => (test) => {
    return hasId.id === test.id;
};
function calculateRegionalFunctionChanges(want, have, options) {
    want = want.filter((fn) => functionsDeployHelper_1.functionMatchesAnyGroup(fn, options.filters));
    have = have.filter((fn) => functionsDeployHelper_1.functionMatchesAnyGroup(fn, options.filters));
    let upgradedToGCFv2WithoutSettingConcurrency = false;
    const functionsToCreate = want.filter((fn) => !have.some(matchesId(fn)));
    const functionsToUpdate = want
        .filter((fn) => {
        const haveFn = have.find(matchesId(fn));
        if (!haveFn) {
            return false;
        }
        validate_1.checkForInvalidChangeOfTrigger(fn, haveFn);
        if (!options.overwriteEnvs) {
            fn.environmentVariables = Object.assign(Object.assign({}, haveFn.environmentVariables), fn.environmentVariables);
        }
        if (haveFn.platform === "gcfv1" && fn.platform === "gcfv2" && !fn.concurrency) {
            upgradedToGCFv2WithoutSettingConcurrency = true;
        }
        return true;
    })
        .map((fn) => {
        const haveFn = have.find(matchesId(fn));
        const deleteAndRecreate = needsDeleteAndRecreate(haveFn, fn);
        return {
            func: fn,
            deleteAndRecreate,
        };
    });
    const functionsToDelete = have
        .filter((fn) => !want.some(matchesId(fn)))
        .filter((fn) => deploymentTool_1.isFirebaseManaged(fn.labels || {}));
    if (upgradedToGCFv2WithoutSettingConcurrency) {
        utils_1.logLabeledBullet("functions", "You are updating one or more functions to Google Cloud Functions v2, " +
            "which introduces support for concurrent execution. New functions " +
            "default to 80 concurrent executions, but existing functions keep the " +
            "old default of 1. You can change this with the 'concurrency' option.");
    }
    return { functionsToCreate, functionsToUpdate, functionsToDelete };
}
exports.calculateRegionalFunctionChanges = calculateRegionalFunctionChanges;
function createDeploymentPlan(want, have, options) {
    const deployment = {
        regionalDeployments: {},
        schedulesToUpsert: [],
        schedulesToDelete: [],
        topicsToDelete: [],
    };
    const wantRegionalFunctions = functionsByRegion(want.cloudFunctions);
    const haveRegionalFunctions = functionsByRegion(have.cloudFunctions);
    for (const region of allRegions(wantRegionalFunctions, haveRegionalFunctions)) {
        const want = wantRegionalFunctions[region] || [];
        const have = haveRegionalFunctions[region] || [];
        deployment.regionalDeployments[region] = calculateRegionalFunctionChanges(want, have, options);
    }
    deployment.schedulesToUpsert = want.schedules.filter((schedule) => functionsDeployHelper_1.functionMatchesAnyGroup(schedule.targetService, options.filters));
    deployment.schedulesToDelete = have.schedules
        .filter((schedule) => !want.schedules.some(matchesId(schedule)))
        .filter((schedule) => functionsDeployHelper_1.functionMatchesAnyGroup(schedule.targetService, options.filters));
    deployment.topicsToDelete = have.topics
        .filter((topic) => !want.topics.some(matchesId(topic)))
        .filter((topic) => functionsDeployHelper_1.functionMatchesAnyGroup(topic.targetService, options.filters));
    return deployment;
}
exports.createDeploymentPlan = createDeploymentPlan;
function needsDeleteAndRecreate(exFn, fn) {
    return changedV2PubSubTopic(exFn, fn);
}
function changedV2PubSubTopic(exFn, fn) {
    if (exFn.platform !== "gcfv2") {
        return false;
    }
    if (fn.platform !== "gcfv2") {
        return false;
    }
    if (!backend.isEventTrigger(exFn.trigger)) {
        return false;
    }
    if (!backend.isEventTrigger(fn.trigger)) {
        return false;
    }
    if (exFn.trigger.eventType !== gcfv2.PUBSUB_PUBLISH_EVENT) {
        return false;
    }
    if (fn.trigger.eventType != gcfv2.PUBSUB_PUBLISH_EVENT) {
        return false;
    }
    return exFn.trigger.eventFilters["resource"] != fn.trigger.eventFilters["resource"];
}
