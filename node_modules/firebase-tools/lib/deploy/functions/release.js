"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.release = void 0;
const queue_1 = require("../../throttler/queue");
const deploymentPlanner_1 = require("./deploymentPlanner");
const functionsConfig_1 = require("../../functionsConfig");
const env_1 = require("../../functions/env");
const prompts_1 = require("./prompts");
const deploymentTimer_1 = require("./deploymentTimer");
const errorHandler_1 = require("./errorHandler");
const previews_1 = require("../../previews");
const backend = require("./backend");
const containerCleaner = require("./containerCleaner");
const helper = require("./functionsDeployHelper");
const tasks = require("./tasks");
const utils = require("../../utils");
const track_1 = require("../../track");
async function release(context, options, payload) {
    if (!options.config.has("functions")) {
        return;
    }
    const projectId = context.projectId;
    const sourceUrl = context.uploadUrl;
    const functionsSource = options.config.get("functions.source");
    const appEngineLocation = functionsConfig_1.getAppEngineLocation(context.firebaseConfig);
    const timer = new deploymentTimer_1.DeploymentTimer();
    const errorHandler = new errorHandler_1.ErrorHandler();
    const fullDeployment = deploymentPlanner_1.createDeploymentPlan(payload.functions.backend, await backend.existingBackend(context), {
        filters: context.filters,
        overwriteEnvs: previews_1.previews.dotenv &&
            env_1.hasUserEnvs({
                functionsSource: options.config.path(functionsSource),
                projectId,
                projectAlias: options.projectAlias,
            }),
    });
    const cloudFunctionsQueue = new queue_1.default({
        retries: 30,
        backoff: 20000,
        concurrency: 40,
        maxBackoff: 40000,
        handler: tasks.functionsDeploymentHandler(timer, errorHandler),
    });
    const schedulerQueue = new queue_1.default({
        handler: tasks.schedulerDeploymentHandler(errorHandler),
    });
    const pubSubQueue = new queue_1.default({
        handler: tasks.schedulerDeploymentHandler(errorHandler),
    });
    const regionPromises = [];
    const taskParams = {
        projectId,
        sourceUrl,
        storage: context.storage,
        errorHandler,
    };
    const allFnsToDelete = Object.values(fullDeployment.regionalDeployments).reduce((accum, region) => [...accum, ...region.functionsToDelete], []);
    const shouldDeleteFunctions = await prompts_1.promptForFunctionDeletion(allFnsToDelete, options.force, options.nonInteractive);
    if (!shouldDeleteFunctions) {
        fullDeployment.schedulesToDelete = fullDeployment.schedulesToDelete.filter((schedule) => {
            return !allFnsToDelete.find(backend.sameFunctionName(schedule.targetService));
        });
        fullDeployment.topicsToDelete = fullDeployment.topicsToDelete.filter((topic) => {
            return !allFnsToDelete.find(backend.sameFunctionName(topic.targetService));
        });
        for (const regionalDeployment of Object.values(fullDeployment.regionalDeployments)) {
            regionalDeployment.functionsToDelete = [];
        }
    }
    for (const [region, deployment] of Object.entries(fullDeployment.regionalDeployments)) {
        regionPromises.push(tasks.runRegionalFunctionDeployment(taskParams, region, deployment, cloudFunctionsQueue));
    }
    for (const schedule of fullDeployment.schedulesToUpsert) {
        const task = tasks.upsertScheduleTask(taskParams, schedule, appEngineLocation);
        void schedulerQueue.run(task);
    }
    for (const schedule of fullDeployment.schedulesToDelete) {
        const task = tasks.deleteScheduleTask(taskParams, schedule, appEngineLocation);
        void schedulerQueue.run(task);
    }
    for (const topic of fullDeployment.topicsToDelete) {
        const task = tasks.deleteTopicTask(taskParams, topic);
        void pubSubQueue.run(task);
    }
    const queuePromises = [cloudFunctionsQueue.wait(), schedulerQueue.wait(), pubSubQueue.wait()];
    cloudFunctionsQueue.process();
    schedulerQueue.process();
    pubSubQueue.process();
    schedulerQueue.close();
    pubSubQueue.close();
    await Promise.all(regionPromises);
    cloudFunctionsQueue.close();
    try {
        await Promise.all(queuePromises);
    }
    catch (err) {
        utils.reject("Exceeded maximum retries while deploying functions. " +
            "If you are deploying a large number of functions, " +
            "please deploy your functions in batches by using the --only flag, " +
            "and wait a few minutes before deploying again. " +
            "Go to https://firebase.google.com/docs/cli/#partial_deploys to learn more.", {
            original: err,
        });
    }
    const functions = payload.functions.backend.cloudFunctions;
    const gcfv1 = functions.find((fn) => fn.platform === "gcfv1");
    const gcfv2 = functions.find((fn) => fn.platform === "gcfv2");
    const tag = gcfv1 && gcfv2 ? "v1+v2" : gcfv1 ? "v1" : "v2";
    track_1.track("functions_codebase_deploy", tag, functions.length);
    helper.logAndTrackDeployStats(cloudFunctionsQueue, errorHandler);
    await containerCleaner.cleanupBuildImages(payload.functions.backend.cloudFunctions);
    await helper.printTriggerUrls(context, payload.functions.backend);
    errorHandler.printWarnings();
    errorHandler.printErrors();
}
exports.release = release;
