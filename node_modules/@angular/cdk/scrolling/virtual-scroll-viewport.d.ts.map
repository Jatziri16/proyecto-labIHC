{"version":3,"file":"virtual-scroll-viewport.d.ts","sources":["virtual-scroll-viewport.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { ListRange } from '@angular/cdk/collections';\r\nimport { ChangeDetectorRef, ElementRef, NgZone, OnDestroy, OnInit } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { ScrollDispatcher } from './scroll-dispatcher';\r\nimport { CdkScrollable } from './scrollable';\r\nimport { VirtualScrollStrategy } from './virtual-scroll-strategy';\r\nimport { ViewportRuler } from './viewport-ruler';\r\nimport { CdkVirtualScrollRepeater } from './virtual-scroll-repeater';\r\n/** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */\r\nexport declare class CdkVirtualScrollViewport extends CdkScrollable implements OnInit, OnDestroy {\r\n    elementRef: ElementRef<HTMLElement>;\r\n    private _changeDetectorRef;\r\n    private _scrollStrategy;\r\n    /** Emits when the viewport is detached from a CdkVirtualForOf. */\r\n    private _detachedSubject;\r\n    /** Emits when the rendered range changes. */\r\n    private _renderedRangeSubject;\r\n    /** The direction the viewport scrolls. */\r\n    get orientation(): 'horizontal' | 'vertical';\r\n    set orientation(orientation: 'horizontal' | 'vertical');\r\n    private _orientation;\r\n    /** Emits when the index of the first element visible in the viewport changes. */\r\n    scrolledIndexChange: Observable<number>;\r\n    /** The element that wraps the rendered content. */\r\n    _contentWrapper: ElementRef<HTMLElement>;\r\n    /** A stream that emits whenever the rendered range changes. */\r\n    renderedRangeStream: Observable<ListRange>;\r\n    /**\r\n     * The total size of all content (in pixels), including content that is not currently rendered.\r\n     */\r\n    private _totalContentSize;\r\n    /** A string representing the `style.width` property value to be used for the spacer element. */\r\n    _totalContentWidth: string;\r\n    /** A string representing the `style.height` property value to be used for the spacer element. */\r\n    _totalContentHeight: string;\r\n    /**\r\n     * The CSS transform applied to the rendered subset of items so that they appear within the bounds\r\n     * of the visible viewport.\r\n     */\r\n    private _renderedContentTransform;\r\n    /** The currently rendered range of indices. */\r\n    private _renderedRange;\r\n    /** The length of the data bound to this viewport (in number of items). */\r\n    private _dataLength;\r\n    /** The size of the viewport (in pixels). */\r\n    private _viewportSize;\r\n    /** the currently attached CdkVirtualScrollRepeater. */\r\n    private _forOf;\r\n    /** The last rendered content offset that was set. */\r\n    private _renderedContentOffset;\r\n    /**\r\n     * Whether the last rendered content offset was to the end of the content (and therefore needs to\r\n     * be rewritten as an offset to the start of the content).\r\n     */\r\n    private _renderedContentOffsetNeedsRewrite;\r\n    /** Whether there is a pending change detection cycle. */\r\n    private _isChangeDetectionPending;\r\n    /** A list of functions to run after the next change detection cycle. */\r\n    private _runAfterChangeDetection;\r\n    /** Subscription to changes in the viewport size. */\r\n    private _viewportChanges;\r\n    constructor(elementRef: ElementRef<HTMLElement>, _changeDetectorRef: ChangeDetectorRef, ngZone: NgZone, _scrollStrategy: VirtualScrollStrategy, dir: Directionality, scrollDispatcher: ScrollDispatcher, viewportRuler: ViewportRuler);\r\n    ngOnInit(): void;\r\n    ngOnDestroy(): void;\r\n    /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */\r\n    attach(forOf: CdkVirtualScrollRepeater<any>): void;\r\n    /** Detaches the current `CdkVirtualForOf`. */\r\n    detach(): void;\r\n    /** Gets the length of the data bound to this viewport (in number of items). */\r\n    getDataLength(): number;\r\n    /** Gets the size of the viewport (in pixels). */\r\n    getViewportSize(): number;\r\n    /** Get the current rendered range of items. */\r\n    getRenderedRange(): ListRange;\r\n    /**\r\n     * Sets the total size of all content (in pixels), including content that is not currently\r\n     * rendered.\r\n     */\r\n    setTotalContentSize(size: number): void;\r\n    /** Sets the currently rendered range of indices. */\r\n    setRenderedRange(range: ListRange): void;\r\n    /**\r\n     * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\r\n     */\r\n    getOffsetToRenderedContentStart(): number | null;\r\n    /**\r\n     * Sets the offset from the start of the viewport to either the start or end of the rendered data\r\n     * (in pixels).\r\n     */\r\n    setRenderedContentOffset(offset: number, to?: 'to-start' | 'to-end'): void;\r\n    /**\r\n     * Scrolls to the given offset from the start of the viewport. Please note that this is not always\r\n     * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\r\n     * direction, this would be the equivalent of setting a fictional `scrollRight` property.\r\n     * @param offset The offset to scroll to.\r\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\r\n     */\r\n    scrollToOffset(offset: number, behavior?: ScrollBehavior): void;\r\n    /**\r\n     * Scrolls to the offset for the given index.\r\n     * @param index The index of the element to scroll to.\r\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\r\n     */\r\n    scrollToIndex(index: number, behavior?: ScrollBehavior): void;\r\n    /**\r\n     * Gets the current scroll offset from the start of the viewport (in pixels).\r\n     * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\r\n     *     in horizontal mode.\r\n     */\r\n    measureScrollOffset(from?: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end'): number;\r\n    /** Measure the combined size of all of the rendered items. */\r\n    measureRenderedContentSize(): number;\r\n    /**\r\n     * Measure the total combined size of the given range. Throws if the range includes items that are\r\n     * not rendered.\r\n     */\r\n    measureRangeSize(range: ListRange): number;\r\n    /** Update the viewport dimensions and re-render. */\r\n    checkViewportSize(): void;\r\n    /** Measure the viewport size. */\r\n    private _measureViewportSize;\r\n    /** Queue up change detection to run. */\r\n    private _markChangeDetectionNeeded;\r\n    /** Run change detection. */\r\n    private _doChangeDetection;\r\n    /** Calculates the `style.width` and `style.height` for the spacer element. */\r\n    private _calculateSpacerSize;\r\n}\r\n"]}