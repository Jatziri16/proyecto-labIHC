{"version":3,"file":"scrollable.d.ts","sources":["scrollable.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { ElementRef, NgZone, OnDestroy, OnInit } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { ScrollDispatcher } from './scroll-dispatcher';\r\nexport declare type _Without<T> = {\r\n    [P in keyof T]?: never;\r\n};\r\nexport declare type _XOR<T, U> = (_Without<T> & U) | (_Without<U> & T);\r\nexport declare type _Top = {\r\n    top?: number;\r\n};\r\nexport declare type _Bottom = {\r\n    bottom?: number;\r\n};\r\nexport declare type _Left = {\r\n    left?: number;\r\n};\r\nexport declare type _Right = {\r\n    right?: number;\r\n};\r\nexport declare type _Start = {\r\n    start?: number;\r\n};\r\nexport declare type _End = {\r\n    end?: number;\r\n};\r\nexport declare type _XAxis = _XOR<_XOR<_Left, _Right>, _XOR<_Start, _End>>;\r\nexport declare type _YAxis = _XOR<_Top, _Bottom>;\r\n/**\r\n * An extended version of ScrollToOptions that allows expressing scroll offsets relative to the\r\n * top, bottom, left, right, start, or end of the viewport rather than just the top and left.\r\n * Please note: the top and bottom properties are mutually exclusive, as are the left, right,\r\n * start, and end properties.\r\n */\r\nexport declare type ExtendedScrollToOptions = _XAxis & _YAxis & ScrollOptions;\r\n/**\r\n * Sends an event when the directive's element is scrolled. Registers itself with the\r\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\r\n * can be listened to through the service.\r\n */\r\nexport declare class CdkScrollable implements OnInit, OnDestroy {\r\n    protected elementRef: ElementRef<HTMLElement>;\r\n    protected scrollDispatcher: ScrollDispatcher;\r\n    protected ngZone: NgZone;\r\n    protected dir?: Directionality | undefined;\r\n    private _destroyed;\r\n    private _elementScrolled;\r\n    constructor(elementRef: ElementRef<HTMLElement>, scrollDispatcher: ScrollDispatcher, ngZone: NgZone, dir?: Directionality | undefined);\r\n    ngOnInit(): void;\r\n    ngOnDestroy(): void;\r\n    /** Returns observable that emits when a scroll event is fired on the host element. */\r\n    elementScrolled(): Observable<Event>;\r\n    /** Gets the ElementRef for the viewport. */\r\n    getElementRef(): ElementRef<HTMLElement>;\r\n    /**\r\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\r\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param options specified the offsets to scroll to.\r\n     */\r\n    scrollTo(options: ExtendedScrollToOptions): void;\r\n    private _applyScrollToOptions;\r\n    /**\r\n     * Measures the scroll offset relative to the specified edge of the viewport. This method can be\r\n     * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\r\n     * about what scrollLeft means in RTL. The values returned by this method are normalized such that\r\n     * left and right always refer to the left and right side of the scrolling container irrespective\r\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\r\n     * in an RTL context.\r\n     * @param from The edge to measure from.\r\n     */\r\n    measureScrollOffset(from: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end'): number;\r\n}\r\n"]}